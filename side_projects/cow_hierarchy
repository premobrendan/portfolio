import React, { useState } from 'react';
import { v4 as uuidv4 } from 'uuid';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { DndProvider, useDrag, useDrop } from 'react-dnd';
import { HTML5Backend } from 'react-dnd-html5-backend';
import * as XLSX from 'xlsx';

const ItemType = 'TREE_NODE';

const InfoModal = ({ node, parent, onClose }) => {
  if (!node) return null;
  return (
    <div className="fixed top-0 left-0 w-full h-full bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-white p-6 rounded shadow-xl max-w-md w-full">
        <h2 className="text-xl font-bold mb-4">Node Details</h2>
        <img src={node.image || 'https://via.placeholder.com/150'} alt="Profile" className="mb-4 w-32 h-32 object-cover rounded-full mx-auto" />
        <p><strong>Name:</strong> {node.label}</p>
        <p><strong>Number:</strong> {node.number || 'N/A'}</p>
        <p><strong>Age:</strong> {node.age || 'N/A'}</p>
        <p><strong>Parents:</strong> {parent ? parent.label : 'None'}</p>
        <p><strong>Children:</strong> {node.children.map(c => c.label).join(', ') || 'None'}</p>
        <div className="mt-4 text-right">
          <Button onClick={onClose}>Close</Button>
        </div>
      </div>
    </div>
  );
};

const TreeNode = ({ node, onAddChild, onDelete, onMoveNode, findNode, parent, onDoubleClick }) => {
  const [showInput, setShowInput] = useState(false);
  const [childLabel, setChildLabel] = useState('');

  const [, dragRef] = useDrag({
    type: ItemType,
    item: { id: node.id },
  });

  const [, dropRef] = useDrop({
    accept: ItemType,
    drop: (item) => {
      if (item.id !== node.id) {
        onMoveNode(item.id, node.id);
      }
    },
  });

  const handleAddChild = () => {
    if (childLabel.trim()) {
      onAddChild(node.id, childLabel.trim());
      setChildLabel('');
      setShowInput(false);
    }
  };

  return (
    <div ref={(el) => dragRef(dropRef(el))} className="ml-4 mt-2 border p-2 rounded shadow-sm">
      <div className="flex items-center space-x-2" onDoubleClick={() => onDoubleClick(node, parent)}>
        <div className="font-semibold cursor-pointer">{node.label}</div>
        <Button size="sm" onClick={() => setShowInput(!showInput)}>Add</Button>
        <Button size="sm" variant="destructive" onClick={() => onDelete(node.id)}>Delete</Button>
      </div>
      {showInput && (
        <div className="flex space-x-2 mt-1">
          <Input
            placeholder="Child label"
            value={childLabel}
            onChange={(e) => setChildLabel(e.target.value)}
            className="w-40"
          />
          <Button size="sm" onClick={handleAddChild}>Add</Button>
        </div>
      )}
      <div className="ml-4">
        {node.children.map((child) => (
          <TreeNode
            key={child.id}
            node={child}
            parent={node}
            onAddChild={onAddChild}
            onDelete={onDelete}
            onMoveNode={onMoveNode}
            findNode={findNode}
            onDoubleClick={onDoubleClick}
          />
        ))}
      </div>
    </div>
  );
};

const InteractiveTree = () => {
  const [treeData, setTreeData] = useState({ id: uuidv4(), label: 'Root', children: [] });
  const [selectedNode, setSelectedNode] = useState(null);
  const [parentNode, setParentNode] = useState(null);

  const addChild = (parentId, label) => {
    const addNode = (node) => {
      if (node.id === parentId) {
        node.children.push({ id: uuidv4(), label, children: [] });
      } else {
        node.children.forEach(addNode);
      }
    };
    const newTree = { ...treeData };
    addNode(newTree);
    setTreeData({ ...newTree });
  };

  const deleteNode = (nodeId) => {
    const deleteRecursively = (node) => {
      node.children = node.children.filter((child) => child.id !== nodeId);
      node.children.forEach(deleteRecursively);
    };
    if (treeData.id === nodeId) return;
    const newTree = { ...treeData };
    deleteRecursively(newTree);
    setTreeData(newTree);
  };

  const findNodeById = (node, id) => {
    if (node.id === id) return node;
    for (let child of node.children) {
      const found = findNodeById(child, id);
      if (found) return found;
    }
    return null;
  };

  const moveNode = (dragId, hoverId) => {
    const clone = JSON.parse(JSON.stringify(treeData));
    let draggedNode = null;

    const removeNode = (node) => {
      node.children = node.children.filter((child) => {
        if (child.id === dragId) {
          draggedNode = child;
          return false;
        }
        removeNode(child);
        return true;
      });
    };
    removeNode(clone);

    const insertNode = (node) => {
      if (node.id === hoverId && draggedNode) {
        node.children.push(draggedNode);
      } else {
        node.children.forEach(insertNode);
      }
    };
    insertNode(clone);
    setTreeData(clone);
  };

  const exportToXLSX = () => {
    const rows = [];
    const traverse = (node, path = []) => {
      rows.push({ Path: path.join(' > '), Label: node.label });
      node.children.forEach((child) => traverse(child, [...path, node.label]));
    };
    traverse(treeData);
    const worksheet = XLSX.utils.json_to_sheet(rows);
    const workbook = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(workbook, worksheet, 'Tree');
    XLSX.writeFile(workbook, 'tree_structure.xlsx');
  };

  const importFromXLSX = (e) => {
    const file = e.target.files[0];
    const reader = new FileReader();
    reader.onload = (evt) => {
      const data = new Uint8Array(evt.target.result);
      const workbook = XLSX.read(data, { type: 'array' });
      const sheet = workbook.Sheets[workbook.SheetNames[0]];
      const rows = XLSX.utils.sheet_to_json(sheet);

      const root = { id: uuidv4(), label: 'Root', children: [] };
      const nodeMap = { '': root };

      rows.forEach(({ Path, Label }) => {
        const parentPath = Path || '';
        const parent = nodeMap[parentPath];
        if (parent) {
          const newNode = { id: uuidv4(), label: Label, children: [] };
          parent.children.push(newNode);
          nodeMap[`${parentPath}${parentPath ? ' > ' : ''}${Label}`] = newNode;
        }
      });

      setTreeData(root);
    };
    reader.readAsArrayBuffer(file);
  };

  const handleDoubleClick = (node, parent) => {
    setSelectedNode(node);
    setParentNode(parent);
  };

  return (
    <DndProvider backend={HTML5Backend}>
      <div className="p-4">
        <h1 className="text-xl font-bold mb-4">Interactive Tree</h1>
        <div className="mb-4 flex space-x-4">
          <Button onClick={exportToXLSX}>Export</Button>
          <Input type="file" accept=".xlsx" onChange={importFromXLSX} />
        </div>
        <TreeNode
          node={treeData}
          onAddChild={addChild}
          onDelete={deleteNode}
          onMoveNode={moveNode}
          findNode={(id) => findNodeById(treeData, id)}
          onDoubleClick={handleDoubleClick}
        />
        {selectedNode && (
          <InfoModal node={selectedNode} parent={parentNode} onClose={() => setSelectedNode(null)} />
        )}
      </div>
    </DndProvider>
  );
};

export default InteractiveTree;
